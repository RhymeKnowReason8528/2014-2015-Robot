#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     touch,          sensorNone)
#pragma config(Sensor, S2,     armInternal,    sensorTouch)
#pragma config(Sensor, S3,     IRSeek,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     armExternal,    sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     belt,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     harvester,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     rightDrive,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftDrive,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(MotorPidSetting,  motorA,  255, 255, 65535, 255, 255,   65535, 65535, 65535)
#pragma config(MotorPidSetting,  motorB,  255, 255, 65535, 255, 255,   65535, 65535, 65535)
#pragma config(MotorPidSetting,  motorC,  255, 255, 65535, 255, 255,   65535, 65535, 65535)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "library\display.h"
#include "library\armControls.c"

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	return;
}

const int OFF_RAMP = 0;
const int START_AT_PARK_ZONE = 1;


task main()
{
	initializeRobot();

	int routineCounter = 0;

	while(nNxtButtonPressed != ORANGE_BUTTON){
		switch((int)nNxtButtonPressed){
		case LEFT_BUTTON:
			while(nNxtButtonPressed == LEFT_BUTTON){}	//empty while to delay until button is released
			routineCounter ++;
			break;
		case RIGHT_BUTTON:
			while(nNxtButtonPressed == RIGHT_BUTTON){}	//empty while to delay until button is released
			routineCounter --;
			break;
		}//end switch
		switch (routineCounter){
		case OFF_RAMP:
			displayBigStringAt(LEFT_X, TOP_Y, "OFF_RAMP");
			break;
		case START_AT_PARK_ZONE:
			displayBigStringAt(LEFT_X, TOP_Y, "PARKING_ZONE");
			break;
		}
	}//end while (should end when Orange button is pressed)

	waitForStart(); // Wait for the beginning of autonomous phase.

	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;

	switch(routineCounter){
	case OFF_RAMP:
		while(nMotorEncoder[rightDrive] > -8500)
		{
			motor[rightDrive] = -50;
			motor[leftDrive] = -50;
		}
		motor[rightDrive] = 0;
		motor[leftDrive] = 0;

		while(getArmPosition() != ARM_EXTENDED)
		{
			motor[arm] = 100;
		}
		motor[arm] = 0;

		break;
		//we may want to mount the sensor at a 30 deggree angle
	case START_AT_PARK_ZONE:
		//if(SensorValue(IRSeek) == /*straight ahead (4?)*/)
		{
			//go straight forward to hit kickstand
		}
		//if(SensorValue(IRSeek) > /*straight ahead (4?) meaning the center module is tilted*/ && SensotValue(IRSeek) < /*farthest to the left meaning center is at second position*/)
		{
			//go forward a little bit then turn and go forward to hit kickstand
		}
		//if(SensorValue(IRSeek) > /*farthest left sensor value, means the center is at third position*/

		/*PSEUDOCODE for START_AT_PARK_ZONE
		sense for IR
		depending on where it is
		go straight forward to hit kickstand
		go forward a little bit then turn and go forward to hit kickstand
		go forward a little, straight, turn, forward to hit kickstand
		stop*/
		break;
	}


	while (true){}//this just keeps the program running until the end of Autonomous
}
